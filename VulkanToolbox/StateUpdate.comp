#version 450
#define QUATERNION_IDENTITY vec4(0, 0, 0, 1)
layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0) buffer PositionData{
    vec4 positions[];
} pData;

struct Velocity
{
	vec4 unitDirection;
	float speed;
};

layout (set = 0, binding = 1) buffer VelocityData{
    Velocity v[];
} vData;

layout (set = 0, binding = 2) buffer MatrixData{
    mat4 rotMatrix[];
} mData;

layout (push_constant) uniform data {
    mat4 PVmatrix;
    float objectCount;
    float deltaTime;
} cData;


vec4 q_look_at(vec3 forward, vec3 up) {
    vec3 right = normalize(cross(forward, up));
    up = normalize(cross(forward, right));

    float m00 = right.x;
    float m01 = right.y;
    float m02 = right.z;
    float m10 = up.x;
    float m11 = up.y;
    float m12 = up.z;
    float m20 = forward.x;
    float m21 = forward.y;
    float m22 = forward.z;

    float num8 = (m00 + m11) + m22;
    vec4 q = QUATERNION_IDENTITY;
    if (num8 > 0.0)
    {
        float num = sqrt(num8 + 1.0);
        q.w = num * 0.5;
        num = 0.5 / num;
        q.x = (m12 - m21) * num;
        q.y = (m20 - m02) * num;
        q.z = (m01 - m10) * num;
        return q;
    }

    if ((m00 >= m11) && (m00 >= m22))
    {
        float num7 = sqrt(((1.0 + m00) - m11) - m22);
        float num4 = 0.5 / num7;
        q.x = 0.5 * num7;
        q.y = (m01 + m10) * num4;
        q.z = (m02 + m20) * num4;
        q.w = (m12 - m21) * num4;
        return q;
    }

    if (m11 > m22)
    {
        float num6 = sqrt(((1.0 + m11) - m00) - m22);
        float num3 = 0.5 / num6;
        q.x = (m10 + m01) * num3;
        q.y = 0.5 * num6;
        q.z = (m21 + m12) * num3;
        q.w = (m20 - m02) * num3;
        return q;
    }

    float num5 = sqrt(((1.0 + m22) - m00) - m11);
    float num2 = 0.5 / num5;
    q.x = (m20 + m02) * num2;
    q.y = (m21 + m12) * num2;
    q.z = 0.5 * num5;
    q.w = (m01 - m10) * num2;
    return q;
}

vec4 q_slerp(vec4 a, vec4 b, float t) {
    // if either input is zero, return the other.
    if (length(a) == 0.0) {
        if (length(b) == 0.0) {
            return QUATERNION_IDENTITY;
        }
        return b;
    } else if (length(b) == 0.0) {
        return a;
    }

    float cosHalfAngle = a.w * b.w + dot(a.xyz, b.xyz);

    if (cosHalfAngle >= 1.0 || cosHalfAngle <= -1.0) {
        return a;
    } else if (cosHalfAngle < 0.0) {
        b.xyz = -b.xyz;
        b.w = -b.w;
        cosHalfAngle = -cosHalfAngle;
    }

    float blendA;
    float blendB;
    if (cosHalfAngle < 0.99) {
        // do proper slerp for big angles
        float halfAngle = acos(cosHalfAngle);
        float sinHalfAngle = sin(halfAngle);
        float oneOverSinHalfAngle = 1.0 / sinHalfAngle;
        blendA = sin(halfAngle * (1.0 - t)) * oneOverSinHalfAngle;
        blendB = sin(halfAngle * t) * oneOverSinHalfAngle;
    } else {
        // do lerp if angle is really small.
        blendA = 1.0 - t;
        blendB = t;
    }

    vec4 result = vec4(blendA * a.xyz + blendB * b.xyz, blendA * a.w + blendB * b.w);
    if (length(result) > 0.0) {
        return normalize(result);
    }
    return QUATERNION_IDENTITY;
}

mat4 matFromQuat(vec4 q)
{
    mat4 rotMat;
    rotMat[0] = vec4((1-2*pow(q.y, 2)-2*pow(q.z, 2)),
                      2*q.x*q.y+2*q.w*q.z,
                      2*q.x*q.z-2*q.w*q.y,
                      0.0f);
    rotMat[1] = vec4(2*q.x*q.y-2*q.w*q.z,
                    (1-2*pow(q.x, 2)-2*pow(q.z, 2)),
                     2*q.y*q.z+q.w*q.x,
                     0.0f);
    rotMat[2] = vec4(2*q.x*q.z+2*q.w*q.y,
                     2*q.y*q.z-2*q.w*q.x,
                     1-2*pow(q.x, 2)-2*pow(q.y, 2),
                     0.0f);
    rotMat[3] = vec4(0,0,0,1);
    return rotMat;
}

vec4 TurnToVector(vec3 startDir, vec3 endDir)
{
    vec3 crossProduct = cross(startDir, endDir);
    float sineOfAngle = length(crossProduct);
    float angle = asin(sineOfAngle);
    vec3 axis = crossProduct/sineOfAngle;
    vec3 imaginary = sin(angle/2.0)*axis;
    vec4 quat;
    quat.w = cos(angle/2.0);
    quat.x = imaginary.x;
    quat.y = imaginary.y;
    quat.z = imaginary.z;

    return quat;
}

void main() {

    uint gID = gl_GlobalInvocationID.x;

    

    if (gID < cData.objectCount)
    {
    vec3 axis = cross(vec3(0,0,1), vData.v[gID].unitDirection.xyz);
    float angle = acos(dot(vec3(0,0,1), vData.v[gID].unitDirection.xyz));
    mat4 rotMat = matFromQuat(q_look_at(vData.v[gID].unitDirection.xyz, vec3(0, -1, 0)));


    pData.positions[gID] = pData.positions[gID] + (vData.v[gID].unitDirection * vData.v[gID].speed * cData.deltaTime);

    mat4 mat;
    mat[0] = vec4(1.0f, 0.0f, 0.0f, 0.0f);
    mat[1] = vec4(0.0f, 1.0f, 0.0f, 0.0f);
    mat[2] = vec4(0.0f, 0.0f, 1.0f, 0.0f);
    mat[3] = pData.positions[gID];
    mData.rotMatrix[gID] = cData.PVmatrix*mat*rotMat;
    }
}